type: edu
files:
- name: src/Task.kt
  visible: true
  placeholders:
  - offset: 0
    length: 51
    placeholder_text: 'class DateRange(val start: MyDate, val end: MyDate)'
    initial_state:
      length: 51
      offset: 0
    initialized_from_dependency: false
    possible_answer: |-
      class DateRange(val start: MyDate, val end: MyDate): Iterable<MyDate>{
          override fun iterator(): Iterator<MyDate> = DateIterator(this)
      }

      class DateIterator(val dateRange:DateRange) : Iterator<MyDate> {
          var current: MyDate = dateRange.start
          override fun next(): MyDate {
              val result = current
              current = current.nextDay()
              return result
          }
          override fun hasNext(): Boolean = current <= dateRange.end
      }
    selected: false
    status: Unchecked
  text: |
    class DateRange(val start: MyDate, val end: MyDate)

    fun iterateOverDateRange(firstDate: MyDate, secondDate: MyDate, handler: (MyDate) -> Unit) {
        for (date in firstDate..secondDate) {
            handler(date)
        }
    }
  learner_created: false
- name: src/DateUtil.kt
  visible: true
  text: |-
    import java.util.Calendar

    fun MyDate.nextDay() = addTimeIntervals(TimeInterval.DAY, 1)

    enum class TimeInterval {
        DAY,
        WEEK,
        YEAR
    }

    fun MyDate.addTimeIntervals(timeInterval: TimeInterval, number: Int): MyDate {
        val c = Calendar.getInstance()
        c.set(year + if (timeInterval == TimeInterval.YEAR) number else 0, month, dayOfMonth)
        var timeInMillis = c.getTimeInMillis()
        val millisecondsInADay = 24 * 60 * 60 * 1000L
        timeInMillis += number * when (timeInterval) {
            TimeInterval.DAY -> millisecondsInADay
            TimeInterval.WEEK -> 7 * millisecondsInADay
            TimeInterval.YEAR -> 0L
        }
        val result = Calendar.getInstance()
        result.setTimeInMillis(timeInMillis)
        return MyDate(result.get(Calendar.YEAR), result.get(Calendar.MONTH), result.get(Calendar.DATE))
    }
  learner_created: false
- name: src/MyDate.kt
  visible: true
  text: |
    data class MyDate(val year: Int, val month: Int, val dayOfMonth: Int) : Comparable<MyDate>{
        override fun compareTo(other: MyDate): Int{
            if(year != other.year) return year - other.year
            if(month != other.month) return month - other.month
            return dayOfMonth - other.dayOfMonth
        }
    }

    operator fun MyDate.rangeTo(other: MyDate) = DateRange(this, other)
  learner_created: false
- name: test/tests.kt
  visible: false
  learner_created: false
status: Unchecked
record: -1
